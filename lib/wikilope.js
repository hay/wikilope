const chalk = require('chalk');
const Configstore = require('configstore');
const log = require('./log.js');
const pkg = require('../package.json');
const { getDomForArticle, getSummaryForArticle } = require('./api.js');

class Wikilope {
    constructor({
        article, debug, language, followRedirects = true, format = 'tree',
        count = 1, useCache = false, steps = 100, recursive = false, json = false
    }) {
        this.article = article;
        this.count = count;
        this.followRedirects = followRedirects;
        this.format = format;
        this.json = json;
        this.language = language;
        this.paths = {};
        this.recursive = recursive;
        this.steps = steps;
        this.useCache = useCache;

        if (debug) {
            log.setLevel(log.LEVEL_DEBUG);
        }

        if (format === 'terms' || json) {
            log.setLevel(log.LEVEL_SILENT);
        }

        if (useCache) {
            this.linkCache = new Configstore(pkg.name);
        }

        log.debug("Setting up the class");
    }

    // The algorithm for getting those links is a bit weird, because
    // getting the first link that doesn't appear within parentheses is hard!
    // So what we do is that we get both the hyperlinks and the summary
    // as generated by the API (which uses lots of clever methods to remove
    // the stuff in brackets. Then we match up the hyperlinks to the text
    // and see which ones remain, then we return those.
    async getFirstLinkForPage(href, count = 1) {
        const doc = await getDomForArticle(this.language, href);
        const summary = await getSummaryForArticle(this.language, href);

        // And now get all the links and make an object
        return Array.from(doc.querySelectorAll('[data-mw-section-id] p [rel="mw:WikiLink"]'))
            .map(link => this.getLinkObject(link))
            .filter(link => summary.includes(link.text) && !link.title.includes(':'))
            .slice(0, count);
    }

    getLinkObject(link) {
        const href = link.href.slice(2);

        return {
            href,
            text : link.text,
            title : link.title,
            url : `https://${this.language}.wikipedia.org/wiki/${encodeURIComponent(href)}`,
        }
    }

    async getTreeFor(href, recursive = true) {
        this.paths[href] = [];
        const path = this.paths[href];
        let steps = this.steps;

        while (steps > 0) {
            let link;

            if (this.useCache && this.linkCache.has(href)) {
                log.debug(`Cache HIT for < ${href} >`);
                link = [ this.linkCache.get(href) ];
            } else {
                log.debug(`Cache MISS for < ${href} >`);
                link = await this.getFirstLinkForPage(href);
            }

            if (link.length) {
                link = link[0];

                if (this.useCache) {
                    log.debug(`Cache SET for < ${href} >`);
                    this.linkCache.set(href, link);
                }

                if (path.filter(p => p.href === link.href).length > 0) {
                    return true;
                } else {
                    if (!recursive) {
                        log.info(`    ${link.title}`)
                    } else {
                        log.info(link.title);
                    }

                    href = link.href;
                    path.push(link);

                    if (recursive && this.recursive) {
                        await this.getTreeFor(href, false);
                    }
                }
            } else {
                log.error('No links from this article');
                return;
            }

            steps = steps - 1;
        }
    }

    async run() {
        let page = this.article;
        log.info(`Getting links for ${chalk.bold(page)}`);

        const starters = await this.getFirstLinkForPage(page, this.count);

        if (starters.length !== this.count) {
            log.error(`Could only get ${starters.length} links to start with (you wanted ${this.count})`);
        }

        for (let index = 0; index < starters.length; index++) {
            let starter = starters[index];

            if (!starter) {
                log.info(`No links for ${page}, aborting`);
                return;
            }

            const msg = `#${index + 1}: ${starter.title}`;
            log.info(`\n${chalk.bold(msg)}`);

            await this.getTreeFor(starter.href);
        }

        if (this.format === 'tree' && this.json) {
            console.log(JSON.stringify(this.paths, null, 4));
        }

        if (this.format === 'terms') {
            let terms = [];

            for (let key in this.paths) {
                let paths = this.paths[key];
                for (let link of paths) {
                    terms.push(link.title);
                }
            }

            terms = Array.from(new Set(terms)).sort();

            if (this.json) {
                console.log(JSON.stringify(terms, null, 4));
            } else {
                console.log(terms.join('\n'));
            }
        }
    }
}

module.exports = Wikilope;