const log = require('./log.js');
const Configstore = require('configstore');
const pkg = require('./package.json');
const { getDomForArticle, getSummaryForArticle } = require('./api.js');

const DEFAULT_ROOT_ARTICLES = ['Language', 'Science', 'Philosophy', 'Physics'];

class GTP {
    constructor({
        article, debug, language, followRedirects = true,
        rootArticles = DEFAULT_ROOT_ARTICLES, stopAtRoot = false,
        stopAtPhilosophy = false, count = 1
    }) {
        if (debug) {
            log.setLevel(log.LEVEL_DEBUG);
        }

        this.article = article;
        this.count = count;
        this.followRedirects = followRedirects;
        this.language = language;
        this.path = [];
        this.rootArticles = rootArticles;
        this.stopAtRoot = stopAtRoot;
        this.stopAtPhilosophy = stopAtPhilosophy;

        log.debug("Setting up the class");
    }

    // The algorithm for getting those links is a bit weird, because
    // getting the first link that doesn't appear within parentheses is hard!
    // So what we do is that we get both the hyperlinks and the summary
    // as generated by the API (which uses lots of clever methods to remove
    // the stuff in brackets. Then we match up the hyperlinks to the text
    // and see which ones remain, then we return those.
    async getFirstLinkForPage(href, count = 1) {
        const doc = await getDomForArticle(this.language, href);
        const summary = await getSummaryForArticle(this.language, href);

        // And now get all the links and make an object
        return Array.from(doc.querySelectorAll('[data-mw-section-id] p [rel="mw:WikiLink"]'))
            .map(link => this.getLinkObject(link))
            .filter(link => summary.includes(link.text))
            .slice(0, count);
    }

    getLinkObject(link) {
        const href = link.href.slice(2);

        return {
            href,
            text : link.text,
            title : link.title,
            url : `https://${this.language}.wikipedia.org/wiki/${encodeURIComponent(href)}`,
        }
    }

    async getTreeFor(href) {
        while (true) {
            let link = await this.getFirstLinkForPage(href);

            if (link.length) {
                link = link[0];

                if (this.hasLink(link)) {
                    log.info(`${link.title} - We've seen that article before, aborting.`);
                    break;
                } else if (this.stopAtRoot && this.rootArticles.includes(link.title)) {
                    log.info(`${link.title} - Root article, stopping here`);
                    break;
                } else if (this.stopAtPhilosophy && link.title === 'Philosophy') {
                    log.info("Philosophy, we're there. Stopping");
                    break;
                } else {
                    log.info(link.title);
                    href = link.href;
                    this.path.push(link);
                }
            } else {
                log.info('NO LINK!');
                break;
            }
        }
    }

    hasLink(link) {
        return this.path.filter(p => p.href === link.href).length > 0;
    }


    async run() {
        let page = this.article;
        log.info(`Getting links for ${page}`);

        const starters = await this.getFirstLinkForPage(page, this.count);

        starters.forEach(async (starter, index) => {
            if (!starter) {
                log.info(`No links for ${page}, aborting`);
                return;
            }

            log.info(`\nGetting tree for link #${index + 1}: < ${starter.title} >`);
            await this.getTreeFor(starter.href);
        });
    }
}

module.exports = GTP;